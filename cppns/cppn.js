(function(exports, selfBrowser, isBrowser){

    var cppn = exports;
    var common = isBrowser ? selfBrowser['common'] : require('../cppnjs.js');
    var utilities = common.loadLibraryFile('cppnjs', 'utilities');

    cppn.CheckDependencies = function()
    {
        utilities = common.loadLibraryFile('cppnjs', 'utilities');
    };

    exports.CheckDependencies = function()
    {
        if(!isBrowser)
            return;

        utilities = selfBrowser['utilities'];
    };

    cppn.CPPN = function( biasNeuronCount,
                          inputNeuronCount,
                          outputNeuronCount,
                          totalNeuronCount,
                          connections,
                          biasList,
                          activationFunctions){

        var self = this;

        self.a = 0;
        self.b = 0;
        self.c = 0;
        self.d = 0;
        self.learningRate = 0;
        self.pre = 0;
        self.post = 0;

        self.adaptable = false;
        self.modulatory = false;

        // must be in the same order as neuronSignals. Has null entries for neurons that are inputs or outputs of a module.
        self.activationFunctions = activationFunctions;

        // The modules and connections are in no particular order; only the order of the neuronSignals is used for input and output methods.
        //floatfastconnections
        self.connections = connections;

        /// The number of bias neurons, usually one but sometimes zero. This is also the index of the first input neuron in the neuron signals.
        self.biasNeuronCount = biasNeuronCount;
        /// The number of input neurons.
        self.inputNeuronCount = inputNeuronCount;
        /// The number of input neurons including any bias neurons. This is also the index of the first output neuron in the neuron signals.
        self.totalInputNeuronCount = self.biasNeuronCount + self.inputNeuronCount;
        /// The number of output neurons.
        self.outputNeuronCount = outputNeuronCount;

        //save the total neuron count for us
        self.totalNeuronCount = totalNeuronCount;

        // For the following array, neurons are ordered with bias nodes at the head of the list,
        // then input nodes, then output nodes, and then hidden nodes in the array's tail.
        self.neuronSignals = [];
        self.modSignals = [];

        // This array is a parallel of neuronSignals, and only has values during SingleStepInternal().
        // It is declared here to avoid having to reallocate it for every network activation.
        self.neuronSignalsBeingProcessed = [];

        //initialize the neuron,mod, and processing signals
        for(var i=0; i < totalNeuronCount; i++){
            //either you are 1 for bias, or 0 otherwise
            self.neuronSignals.push(i < self.biasNeuronCount ? 1 : 0);
            self.modSignals.push(0);
            self.neuronSignalsBeingProcessed.push(0);
        }

        self.biasList = biasList;

        // For recursive activation, marks whether we have finished this node yet
        self.activated = [];
        // For recursive activation, makes whether a node is currently being calculated. For recurrant connections
        self.inActivation = [];
        // For recursive activation, the previous activation for recurrent connections
        self.lastActivation = [];


        self.adjacentList = [];
        self.reverseAdjacentList = [];
        self.adjacentMatrix = [];


        //initialize the activated, in activation, previous activation
        for(var i=0; i < totalNeuronCount; i++){
            self.activated.push(false);
            self.inActivation.push(false);
            self.lastActivation.push(0);

            //then we initialize our list of lists!
            self.adjacentList.push([]);
            self.reverseAdjacentList.push([]);

            self.adjacentMatrix.push([]);
            for(var j=0; j < totalNeuronCount; j++)
            {
                self.adjacentMatrix[i].push(0);
            }
        }

//        console.log(self.adjacentList.length);

        //finally
        // Set up adjacency list and matrix
        for (var i = 0; i < self.connections.length; i++)
        {
            var crs = self.connections[i].sourceIdx;
            var crt = self.connections[i].targetIdx;

            // Holds outgoing nodes
            self.adjacentList[crs].push(crt);

            // Holds incoming nodes
            self.reverseAdjacentList[crt].push(crs);

            self.adjacentMatrix[crs][crt] = connections[i].weight;
        }
    };
    /// <summary>
    /// This function carries out a single network activation.
    /// It is called by all those methods that require network activations.
    /// </summary>
    /// <param name="maxAllowedSignalDelta">
    /// The network is not relaxed as long as the absolute value of the change in signals at any given point is greater than this value.
    /// Only positive values are used. If the value is less than or equal to 0, the method will return true without checking for relaxation.
    /// </param>
    /// <returns>True if the network is relaxed, or false if not.</returns>
    cppn.CPPN.prototype.singleStepInternal = function(maxAllowedSignalDelta)
    {
        var isRelaxed = true;	// Assume true.
        var self = this;
        // Calculate each connection's output signal, and add the signals to the target neurons.
        for (var i = 0; i < self.connections.length; i++) {

            if (self.adaptable)
            {
                if (self.connections[i].modConnection <= 0.0)   //Normal connection
                {
                    self.neuronSignalsBeingProcessed[self.connections[i].targetIdx] += self.neuronSignals[self.connections[i].sourceIdx] * self.connections[i].weight;
                }
            else //modulatory connection
                {
                    self.modSignals[self.connections[i].targetIdx] += self.neuronSignals[self.connections[i].sourceIdx] * self.connections[i].weight;

                }
            }
            else
            {
                self.neuronSignalsBeingProcessed[self.connections[i].targetIdx] += self.neuronSignals[self.connections[i].sourceIdx] * self.connections[i].weight;

            }
        }

        // Pass the signals through the single-valued activation functions.
        // Do not change the values of input neurons or neurons that have no activation function because they are part of a module.
        for (var i = self.totalInputNeuronCount; i < self.neuronSignalsBeingProcessed.length; i++) {
            self.neuronSignalsBeingProcessed[i] = self.activationFunctions[i].calculate(self.neuronSignalsBeingProcessed[i]+self.biasList[i]);
            if (self.modulatory)
            {
                //Make sure it's between 0 and 1
                self.modSignals[i] += 1.0;
                if (self.modSignals[i]!=0.0)
                self.modSignals[i] = utilities.tanh(self.modSignals[i]);//Tanh(modSignals[i]);//(Math.Exp(2 * modSignals[i]) - 1) / (Math.Exp(2 * modSignals[i]) + 1));
            }
        }
        //TODO Modules not supported in this implementation - don't care


        /*foreach (float f in neuronSignals)
         HyperNEATParameters.distOutput.Write(f.ToString("R") + " ");
         HyperNEATParameters.distOutput.WriteLine();
         HyperNEATParameters.distOutput.Flush();*/

        // Move all the neuron signals we changed while processing this network activation into storage.
        if (maxAllowedSignalDelta > 0) {
            for (var i = self.totalInputNeuronCount; i < self.neuronSignalsBeingProcessed.length; i++) {

                // First check whether any location in the network has changed by more than a small amount.
                isRelaxed &= (Math.abs(self.neuronSignals[i] - self.neuronSignalsBeingProcessed[i]) > maxAllowedSignalDelta);

                self.neuronSignals[i] = self.neuronSignalsBeingProcessed[i];
                self.neuronSignalsBeingProcessed[i] = 0.0;
            }
        } else {
            for (var i = self.totalInputNeuronCount; i < self.neuronSignalsBeingProcessed.length; i++) {
                self.neuronSignals[i] = self.neuronSignalsBeingProcessed[i];
                self.neuronSignalsBeingProcessed[i] = 0.0;
            }
        }

        // Console.WriteLine(inputNeuronCount);

        if (self.adaptable)//CPPN != null)
        {
            var coordinates = new float[4];
            var modValue;
            var weightDelta;
            for (var i = 0; i < self.connections.length; i++)
            {
                if (self.modulatory)
                {
                    self.pre = self.neuronSignals[self.connections[i].sourceIdx];
                    self.post = self.neuronSignals[self.connections[i].targetIdx];
                    modValue = self.modSignals[self.connections[i].targetIdx];

                    self.a = self.connections[i].a;
                    self.b = self.connections[i].b;
                    self.c = self.connections[i].c;
                    self.d = self.connections[i].d;

                    self.learningRate = self.connections[i].learningRate;
                    if (modValue != 0.0 && (self.connections[i].modConnection <= 0.0))        //modulate target neuron if its a normal connection
                    {
                        self.connections[i].weight += modValue*self.learningRate * (self.a * self.pre * self.post + self.b * self.pre + self.c * self.post + self.d);
                    }

                    if (Math.abs(self.connections[i].weight) > 5.0)
                    {
                        self.connections[i].weight = 5.0 * utilities.sign(self.connections[i].weight);
                    }
                }
                else
                {
                    self.pre = self.neuronSignals[self.connections[i].sourceIdx];
                    self.post = self.neuronSignals[self.connections[i].targetIdx];
                    self.a = self.connections[i].a;
                    self.b = self.connections[i].b;
                    self.c = self.connections[i].c;

                    self.learningRate = self.connections[i].learningRate;

                    weightDelta = self.learningRate * (self.a * self.pre * self.post + self.b * self.pre + self.c * self.post);
                    connections[i].weight += weightDelta;

                    //   Console.WriteLine(pre + " " + post + " " + learningRate + " " + A + " " + B + " " + C + " " + weightDelta);

                    if (Math.abs(self.connections[i].weight) > 5.0)
                    {
                        self.connections[i].weight = 5.0 * utilities.sign(self.connections[i].weight);
                    }
                }
            }
        }

        for (var i = self.totalInputNeuronCount; i < self.neuronSignalsBeingProcessed.length; i++)
        {
            self.modSignals[i] = 0.0;
        }

        return isRelaxed;

    };


    cppn.CPPN.prototype.singleStep = function(finished)
    {
        var self = this;
        self.singleStepInternal(0.0); // we will ignore the value of this function, so the "allowedDelta" argument doesn't matter.
        if (finished)
        {
            finished(null);
        }
    };

    cppn.CPPN.prototype.multipleSteps = function(numberOfSteps)
    {
        var self = this;
        for (var i = 0; i < numberOfSteps; i++) {
            self.singleStep();
        }
    };

    /// <summary>
    /// Using RelaxNetwork erodes some of the perofrmance gain of FastConcurrentNetwork because of the slightly
    /// more complex implemementation of the third loop - whe compared to SingleStep().
    /// </summary>
    /// <param name="maxSteps"></param>
    /// <param name="maxAllowedSignalDelta"></param>
    /// <returns></returns>
    cppn.CPPN.prototype.relaxNetwork = function(maxSteps, maxAllowedSignalDelta)
    {
        var self = this;
        var isRelaxed = false;
        for (var j = 0; j < maxSteps && !isRelaxed; j++) {
            isRelaxed = self.singleStepInternal(maxAllowedSignalDelta);
        }
        return isRelaxed;
    };

    cppn.CPPN.prototype.setInputSignal = function(index, signalValue)
    {
        var self = this;
        // For speed we don't bother with bounds checks.
        self.neuronSignals[self.biasNeuronCount + index] = signalValue;
    };

    cppn.CPPN.prototype.setInputSignals = function(signalArray)
    {
        var self = this;
        // For speed we don't bother with bounds checks.
        for (var i = 0; i < signalArray.length; i++)
            self.neuronSignals[self.biasNeuronCount + i] = signalArray[i];
    };

    //we can dispense of this by accessing neuron signals directly
    cppn.CPPN.prototype.getOutputSignal = function(index)
    {
        // For speed we don't bother with bounds checks.
        return this.neuronSignals[this.totalInputNeuronCount + index];
    };

    //we can dispense of this by accessing neuron signals directly
    cppn.CPPN.prototype.clearSignals = function()
    {
        var self = this;
        // Clear signals for input, hidden and output nodes. Only the bias node is untouched.
        for (var i = self.biasNeuronCount; i < self.neuronSignals.length; i++)
            self.neuronSignals[i] = 0.0;
    };

//    cppn.CPPN.prototype.TotalNeuronCount = function(){ return this.neuronSignals.length;};

    cppn.CPPN.prototype.recursiveActivation = function(){

        var self = this;
        // Initialize boolean arrays and set the last activation signal, but only if it isn't an input (these have already been set when the input is activated)
        for (var i = 0; i < self.neuronSignals.length; i++)
        {
            // Set as activated if i is an input node, otherwise ensure it is unactivated (false)
            self.activated[i] = (i < self.totalInputNeuronCount) ? true : false;
            self.inActivation[i] = false;
            if (i >= self.totalInputNeuronCount)
                self.lastActivation[i] = self.neuronSignals[i];
        }

        // Get each output node activation recursively
        // NOTE: This is an assumption that genomes have started minimally, and the output nodes lie sequentially after the input nodes
        for (var i = 0; i < self.outputNeuronCount; i++)
            self.recursiveActivateNode(self.totalInputNeuronCount + i);

    };


    cppn.CPPN.prototype.recursiveActivateNode = function(currentNode)
    {
        var self = this;
        // If we've reached an input node we return since the signal is already set
        if (self.activated[currentNode])
        {
            self.inActivation[currentNode] = false;
            return;
        }

        // Mark that the node is currently being calculated
        self.inActivation[currentNode] = true;

        // Set the presignal to 0
        self.neuronSignalsBeingProcessed[currentNode] = 0;

        // Adjacency list in reverse holds incoming connections, go through each one and activate it
        for (var i = 0; i < self.reverseAdjacentList[currentNode].length; i++)
        {
            var crntAdjNode = self.reverseAdjacentList[currentNode][i];

            //{ Region recurrant connection handling - not applicable in our implementation
            // If this node is currently being activated then we have reached a cycle, or recurrant connection. Use the previous activation in this case
            if (self.inActivation[crntAdjNode])
            {
                console.log('using last activation!');
                self.neuronSignalsBeingProcessed[currentNode] += self.lastActivation[crntAdjNode]*self.adjacentMatrix[crntAdjNode][currentNode];
//                    parseFloat(
//                    parseFloat(self.lastActivation[crntAdjNode].toFixed(9)) * parseFloat(self.adjacentMatrix[crntAdjNode][currentNode].toFixed(9)).toFixed(9));
            }

            // Otherwise proceed as normal
            else
            {
                // Recurse if this neuron has not been activated yet
                if (!self.activated[crntAdjNode])
                    self.recursiveActivateNode(crntAdjNode);

                // Add it to the new activation
                self.neuronSignalsBeingProcessed[currentNode] +=  self.neuronSignals[crntAdjNode] *self.adjacentMatrix[crntAdjNode][currentNode];
//                    parseFloat(
//                    parseFloat(self.neuronSignals[crntAdjNode].toFixed(9)) * parseFloat(self.adjacentMatrix[crntAdjNode][currentNode].toFixed(9)).toFixed(9));
            }
            //} endregion
        }

        // Mark this neuron as completed
        self.activated[currentNode] = true;

        // This is no longer being calculated (for cycle detection)
        self.inActivation[currentNode] = false;

//        console.log('Current node: ' + currentNode);
//        console.log('ActivationFunctions: ');
//        console.log(self.activationFunctions);
//
//        console.log('neuronSignals: ');
//        console.log(self.neuronSignals);
//
//        console.log('neuronSignalsBeingProcessed: ');
//        console.log(self.neuronSignalsBeingProcessed);
        // Set this signal after running it through the activation function
        self.neuronSignals[currentNode] = self.activationFunctions[currentNode].calculate(self.neuronSignalsBeingProcessed[currentNode]);
//            parseFloat((self.activationFunctions[currentNode].calculate(parseFloat(self.neuronSignalsBeingProcessed[currentNode].toFixed(9)))).toFixed(9));

    };


    cppn.CPPN.prototype.isRecursive = function()
    {
        var self = this;

        //if we're a hidden/output node (nodeid >= totalInputcount), and we connect to an input node (nodeid <= self.totalInputcount) -- it's recurrent!
        //if we are a self connection, duh we are recurrent
        for(var c=0; c< self.connections.length; c++)
            if((self.connections[c].sourceIdx >= self.totalInputNeuronCount
                && self.connections[c].targetIdx < self.totalInputNeuronCount)
                || self.connections[c].sourceIdx == self.connections[c].targetIdx
                )
                return true;

        self.recursed = [];
        self.inRecursiveCheck = [];


        for(var i=0; i < self.neuronSignals.length; i++)
        {

            self.recursed.push((i < self.totalInputNeuronCount) ? true : false);
            self.inRecursiveCheck.push(false);
        }

        // Get each output node activation recursively
        // NOTE: This is an assumption that genomes have started minimally, and the output nodes lie sequentially after the input nodes
        for (var i = 0; i < self.outputNeuronCount; i++){
            if(self.recursiveCheckRecursive(self.totalInputNeuronCount + i))
            {
//                console.log('Returned one!');
                return true;

            }
        }

        return false;

    };

    cppn.CPPN.prototype.recursiveCheckRecursive = function(currentNode)
    {
        var self = this;


//        console.log('Self recursed : '+ currentNode + ' ? ' +  self.recursed[currentNode]);

//        console.log('Checking: ' + currentNode)
        //  If we've reached an input node we return since the signal is already set
        if (self.recursed[currentNode])
        {
            self.inRecursiveCheck[currentNode] = false;
            return false;
        }

        // Mark that the node is currently being calculated
        self.inRecursiveCheck[currentNode] = true;

            // Adjacency list in reverse holds incoming connections, go through each one and activate it
            for (var i = 0; i < self.reverseAdjacentList[currentNode].length; i++)
            {
                var crntAdjNode = self.reverseAdjacentList[currentNode][i];

                //{ Region recurrant connection handling - not applicable in our implementation
                // If this node is currently being activated then we have reached a cycle, or recurrant connection. Use the previous activation in this case
                if (self.inRecursiveCheck[crntAdjNode])
                {
                    self.inRecursiveCheck[currentNode] = false;
                    return true;
                }

                // Otherwise proceed as normal
                else
                {
                    var verifiedRecursive;
                    // Recurse if this neuron has not been activated yet
                    if (!self.recursed[crntAdjNode])
                        verifiedRecursive = self.recursiveCheckRecursive(crntAdjNode);

                    if(verifiedRecursive)
                        return true;
                }
                //} endregion
            }

            // Mark this neuron as completed
            self.recursed[currentNode] = true;

            // This is no longer being calculated (for cycle detection)
            self.inRecursiveCheck[currentNode] = false;

            return false;
    };


    cppn.CPPN.prototype.recursiveEnclosure = function(){

        var self = this;

        var functions = [];
        self.inEnclose = [];

        // Initialize boolean arrays and set the last activation signal, but only if it isn't an input (these have already been set when the input is activated)
        for (var i = 0; i < self.neuronSignals.length; i++)
        {
            // Set as activated if i is an input node, otherwise ensure it is unactivated (false)
            self.inEnclose.push(false);
        }

        var inputs = [];

        for(var i=self.biasNeuronCount; i < self.totalInputNeuronCount; i++)
            inputs.push('x' + i);


        // Get each output node activation recursively
        // NOTE: This is an assumption that genomes have started minimally, and the output nodes lie sequentially after the input nodes
        for (var i = 0; i < self.outputNeuronCount; i++){
            var usedInputs = [];
            var fString = self.beginningFunction()
                 + self.recursiveEncloseNode(self.totalInputNeuronCount + i);

            for(var ins =0; ins < inputs.length; ins++)
            {
               if(fString.indexOf(inputs[ins]) !== -1)
               {
                   usedInputs.push(inputs[ins]);
               }
            }

            functions.push({inputs: usedInputs, functionString: fString, function: new Function(inputs, fString)});
        }
        return functions;

    };
    cppn.CPPN.prototype.beginningFunction = function()
    {
        var biasString = '';
        for(var b=0; b < this.biasNeuronCount; b++)
            biasString += 'var x' + b + ' = 1;';

        //mwahahahaha - set our bias object!
        return biasString + 'return ';

    };
    cppn.CPPN.prototype.doesContain = function(arr, obj)
    {
        for(var i=0; i < arr.length; i++)
        {
            if(arr[i] === obj)
                return true;
        }
        return false;
    }
    cppn.CPPN.prototype.recursiveEncloseNode = function(currentNode)
    {
        var self = this;

        if(currentNode < self.totalInputNeuronCount)
            return "x" + currentNode;

        self.inEnclose[currentNode] = true;

        var compiledFunction = '';

        // Adjacency list in reverse holds incoming connections, go through each one and activate it
        for (var i = 0; i < self.reverseAdjacentList[currentNode].length; i++)
        {
            var crntAdjNode = self.reverseAdjacentList[currentNode][i];

            if(self.inEnclose[crntAdjNode])
            {
                //don't enclose this node, since we've detected a loop here, abandon it!
                throw new Error("Method not built for recurrent networks!")
            }

            var recursedFunction = self.recursiveEncloseNode(crntAdjNode);

            //if wer're non-empty, add some weigths and what have you!
            if(recursedFunction !== '')
                compiledFunction +=  (i === 0 ? '(' : ' + ') + self.adjacentMatrix[crntAdjNode][currentNode] + '*' + recursedFunction;
        }

        //if we're empty, we're empty! We don't go no where, derrrr
        if(compiledFunction === '')
            compiledFunction = '0.0';
        else
            compiledFunction += ')';

        self.inEnclose[currentNode] = false;

        //otherwise, return our object activated
        return self.activationFunctions[currentNode].enclose(compiledFunction);
    };






    //send in the object, and also whetehr or not this is nodejs
})(typeof exports === 'undefined'? this['cppnjs']['cppn']={}: exports, this, typeof exports === 'undefined'? true : false);
